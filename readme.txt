ΖΗΤΟΥΜΕΝΟ 1
Ο κώδικάς μου βρίσκεται σε 3 φακέλους. Στον src βρίσκονται τα προγράμματα sniffer, που είναι η διεργασία manager, και worker. Στον modules βρίσκονται προγράμματα
με συναρτήσεις που χρησιμοποιούνται από τον sniffer(manager) και από τους workers. Στον include βρίσκονται τα headers.
SNIFFER.CPP
Αλλάζω τον χειρισμό των signals SIGINT και SIGCHLD.
Ανοίγω το directory που μου έχει δωθεί (είναι γραμμένο στο Makefile, στο ./sniffer -p test). Το test είναι ένας φάκελος με τα δύο πρώτα αρχεία-παραδείγματα που δόθηκαν. Αν
δεν έχει δωθεί directory ανοίγω το current working directory. 
Έπειτα φτιάχνω το pipe με το οποίο θα επικοινωνώ με τον listener.
Κάνω fork() και ενώνω το write άκρο του pipe με τη διεργασία παιδί (listener), κάνοντας τον περιγραφέα αρχείου 1 (της προκαθορισμένης εξόδου) να αντιστοιχεί στο write end του pipe.
Η διεργασία παιδί επίσης κλείνει το read end.
Καλώ με την execlp την inotifywait με τα ορίσματα:
-m : monitoring
-r : quiet
-e create : only notify at the event of file creation
--format %w%f : output watched directory and file that caused event (dir/file)
Η διεργασία γονέας κλείνει το write end του pipe.
Για κάθε αρχείο του directory φτιάχνω έναν worker και του αναθέτω ένα αρχείο προς επεξεργασία.
ΔΗΜΙΟΥΡΓΙΑ WORKER (create_worker στο modules/manageWorkers.cpp): δημιουργώ μία fifo στον φάκελο fifos. Καλώ fork() και ο γονέας manager και το παιδί worker ανοίγουν την fifo ταυτόχρονα. 
Κάνω execl για να εκτελέσει η διεργασία worker το προγραμμά worker. Περνάω ως όρισμα τον περιγραφέα αρχείου του read end του named pipe. Για κάθε worker κρατάω σε μία δομή το pid του και 
τον περιγραφέα αρχείου του write end του named pipe για τον γονεα. Σε ένα vector κρατάω όλους τους workers και στην ουρά free_workers τους διαθέσιμους.
Ο worker διαβάζει από τη fifo το όνομα αρχείου προς επεξεργασία. Ανοίγει το αρχείο. 
Διαβάζει το αρχείο κατά γράμμα (κατά γράμμα ώστε να μπορώ να επεξεργαστώ μεγαλύτερα αρχεία) αθροίζοντας σε ένα string και όταν φτάσει σε κενό ελέγχει αν στο string που διάβασε 
εμπεριέχει url της μορφής που περιγράφει το regular expression "http://[^ ]+ ".
(Για τη δημιουργία του regex έδωσα κυρίως σημασία στο ότι το url ξεκινά με "http://" , δεν περιέχει whitespaces και τελειώνει με space)
Όταν βρω url καλώ την extract_location (modules/location.cpp) η οποία αποσπά το location. Κρατάω πληροφορία για τα locations σε δομή struct token, το location ως character array 
και τις φορές που έχει εμφανιστεί. Κοιτάω στο vector που αποθηκεύω τα locations αν έχει ξαναβρεθεί το συγκεκριμένο, αν ναι αυξάνω το πεδίο times κατά 1, αλλιώς φτιάχνω νέο αντικείμενο
και το προσθέτω στο vector (set_location στο location.cpp).
Δημιουργώ νέο αρχείο <filename>.out στον φάκελο results. Γράφω τα locations από το vector καλώντας την write_locations και αδειάζω το vector ώστε να ξαναχρησιμοποιηθεί για άλλα αρχεία.
Στέλνω signal SIGSTOP στον εαυτό μου (ως worker).
Ο manager γονέας πιάνει το SIGCHLD 	που του στέλνεται και εκτελεί την συνάρτηση myhandler1, με waitpid παίρνει το pid του παιδιού και καλεί dismiss_worker για να ξαναμπεί ο worker στην 
ουρά των διαθέσιμων.
Κάθε φορά που ανιχνλευει ο listener καινούριο αρχείο στο directory, ο manager καλεί hire_worker (modules/manageWorkers.cpp) και του επιστρέφεται worker είναι από την ουρά, είτε αν είναι
άδεια καινούριος. Αν ήταν σταματημένος του στέλνει σήμα SIGCONT.
Με control+c το πρόγραμμα τερματίζει. Ο manager λαμβάνει σήμα SIGINT και κάλει τον myhandler2, ο οποίος κλείνει το directory και καλεί kill για τον listener και τους workers.
ΓΕΝΙΚΑ: Ό,τι εκτυπώνεται είναι για δική μου διευκόλυνση και μπορεί να αγνοηθεί.

ΖΗΤΟΥΜΕΝΟ 2
Δίνοντας ως όρισμα οποιόδηποτε TLD παίρνω τον αριθμό εμφάνισης του στα αρχεία του φακέλου results.
Αν δοθούν ως παράμετροι περισσότερα από ένα TLDs τότε δίπλα από τον αριθμό εμφανίζεται και το TLD για να μπορώ να τα ξεχωρίζω.

ΤΡΟΠΟΣ ΜΕΤΑΓΛΩΤΤΙΣΗΣ-ΕΚΤΕΛΕΣΗΣ
Ζητούμενο 1: μεταγλώττιση       make
             εκτέλεση           make run
             καθάρισμα          make clean
ΔΙΕΥΚΡΙΝΗΣΕΙΣ MAKEFILE: Το Makefile μου βρίσκεται στον βασικό φάκελο. Με make run αυτομάτως έχω βάλει να αδειάζουν οι φάκελοι results και fifos ώστε να μπορέσει να τρέξει από την αρχή
                        χωρίς απρόοπτα. Επίσης ο φάκελος που θα χειριστεί το πρόγραμμα δίνεται στο Makefile, δίπλα στο ./sniffer ως "-p <dir>". Έχω βάλει τον φάκελο test στον οποίο
                        βρίσκονται τα 10_urls.txt και 100_urls.txt. Το 50_urls.txt βρίσκεται στον βασικό φάκελο και ενώ τρέχει το πρόγραμμα σε ένα άλλο παράθυρο με εντολή 
                        "cp 50_urls.txt test" μπορεί να φανεί η αποτελεσματικότητα του listener.
Ζητούμενο 2: εκτέλεση           ./finder.sh <tld1> <tld2> <tld3> ...
             Παράδειγμα: ./finder.sh com gr uk ge ru        